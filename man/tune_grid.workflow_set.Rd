% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tune-functions.R
\name{tune_grid.workflow_set}
\alias{tune_grid.workflow_set}
\alias{tune_bayes.workflow_set}
\alias{fit_resamples.workflow_set}
\title{Methods for processing workflow sets}
\usage{
\method{tune_grid}{workflow_set}(object, ..., which = NULL, seed = sample(1e+05, 1), verbose = FALSE)

\method{tune_bayes}{workflow_set}(object, ..., which = NULL, seed = sample(1e+05, 1), verbose = FALSE)

\method{fit_resamples}{workflow_set}(
  object,
  ...,
  which = NULL,
  seed = sample(1e+05, 1),
  verbose = FALSE
)
}
\arguments{
\item{object}{A \code{workflow_set} object.}

\item{...}{Common arguments that will be passed to each \code{tune} function. These
should not be the same arguments passed to \code{options}.}

\item{which}{A character string of identifiers indicating which workflows should
be processed. If left \code{NULL}, all applicable workflows without entries
in the \code{results} column are selected.}

\item{seed}{A single integer that is set before each workflow is processed.}

\item{verbose}{A single logical to indicate if logging should occur. This
will write a message \emph{after} each workflow is process and indicates if there
were any issues.}
}
\value{
An object from the corresponding \code{tune} package function (e.g. with
class \code{tune_result}, etc.)
}
\description{
Methods for processing workflow sets
}
\examples{
library(workflowsets)
library(modeldata)
library(recipes)
library(parsnip)
library(dplyr)
library(rsample)
library(tune)
library(yardstick)
library(dials)

# ------------------------------------------------------------------------------

data(cells)
cells <- cells \%>\% dplyr::select(-case)

set.seed(1)
val_set <- validation_split(cells)

# ------------------------------------------------------------------------------

basic_recipe <-
   recipe(class ~ ., data = cells) \%>\%
   step_YeoJohnson(all_predictors()) \%>\%
   step_normalize(all_predictors())

pca_recipe <-
   basic_recipe \%>\%
   step_pca(all_predictors(), num_comp = tune())

ss_recipe <-
   basic_recipe \%>\%
   step_spatialsign(all_predictors())

# ------------------------------------------------------------------------------

knn_mod <-
   nearest_neighbor(neighbors = tune(), weight_func = tune()) \%>\%
   set_engine("kknn") \%>\%
   set_mode("classification")

lr_mod <-
   logistic_reg() \%>\%
   set_engine("glm")

# ------------------------------------------------------------------------------

preproc <- list(none = basic_recipe, pca = pca_recipe, sp_sign = ss_recipe)
models <- list(knn = knn_mod, logistic = lr_mod)

cell_models <- workflow_set(preproc, models, cross = TRUE)

# ------------------------------------------------------------------------------

\donttest{
cell_model_results <-
   cell_models \%>\%
   tune_grid(resamples = val_set, grid = 10, metrics = metric_set(roc_auc)) \%>\%
   fit_resamples(resamples = val_set, metrics = metric_set(roc_auc))
cell_model_results
}

# ------------------------------------------------------------------------------

# An example of setting options. Let's change the range for `num_comp` by
# passing a specific parameter set.
# pca_knn_mod <-
#   cell_models \%>\%
#   dplyr::filter(wflow_id == "pca_knn")
# pca_knn_param <-
#   pca_knn_mod$object[[1]] \%>\%
#   parameters() \%>\%
#   update(num_comp = num_comp(c(0, 20)))
#
# new_opts <- list(pca_knn = list(param_info = pca_knn_param))
# new_opts
# \donttest{
# cell_model_results <-
#    cell_models \%>\%
#    tune_grid(resamples = val_set, grid = 10, which = "pca_knn", options = new_opts)
# }
}
