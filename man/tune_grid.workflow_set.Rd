% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tune-functions.R
\name{tune_grid.workflow_set}
\alias{tune_grid.workflow_set}
\alias{tune_bayes.workflow_set}
\alias{fit_resamples.workflow_set}
\title{Methods for processing workflow sets}
\usage{
\method{tune_grid}{workflow_set}(
  object,
  pick = NULL,
  options = NULL,
  seed = sample(1e+05, 1),
  verbose = FALSE,
  ...
)

\method{tune_bayes}{workflow_set}(
  object,
  pick = NULL,
  options = NULL,
  seed = sample(1e+05, 1),
  verbose = FALSE,
  ...
)

\method{fit_resamples}{workflow_set}(
  object,
  pick = NULL,
  options = NULL,
  seed = sample(1e+05, 1),
  verbose = FALSE,
  ...
)
}
\arguments{
\item{object}{A \code{workflow_set} object.}

\item{pick}{A character string of identifiers indicating which workflows should
be processed. If left \code{NULL}, all applicable workflows without entries
in the \code{results} column are selected.}

\item{options}{A list the same length as \code{pick} with workflow-specific
arguments to the corresponding function in the \code{tune} package.}

\item{seed}{A single integer that is set before each workflow is processed.}

\item{verbose}{A single logical to indicate if logging should occur. This
will write a message \emph{after} each workflow is process and indicates if there
were any issues.}

\item{...}{Common arguments that will be passed to each \code{tune} function. These
should not be the same arguments passed to \code{options}.}
}
\value{
An object from the corresponding \code{tune} package function (e.g. with
class \code{tune_result}, etc.)
}
\description{
Methods for processing workflow sets
}
\examples{
library(tbd)
library(modeldata)
library(recipes)
library(parsnip)
library(dplyr)
library(rsample)
library(tune)
library(yardstick)

# ------------------------------------------------------------------------------

data(cells)
cells <- cells \%>\% dplyr::select(-case)

set.seed(1)
val_set <- validation_split(cells)

# ------------------------------------------------------------------------------

basic_recipe <-
   recipe(class ~ ., data = cells) \%>\%
   step_YeoJohnson(all_predictors()) \%>\%
   step_normalize(all_predictors())

pca_recipe <-
   basic_recipe \%>\%
   step_pca(all_predictors(), num_comp = tune())

ss_recipe <-
   basic_recipe \%>\%
   step_spatialsign(all_predictors())

# ------------------------------------------------------------------------------

knn_mod <-
   nearest_neighbor(neighbors = tune(), weight_func = tune()) \%>\%
   set_engine("kknn") \%>\%
   set_mode("classification")

lr_mod <-
   logistic_reg() \%>\%
   set_engine("glm")

# ------------------------------------------------------------------------------

preproc <- list(none = basic_recipe, pca = pca_recipe, sp_sign = ss_recipe)
models <- list(knn = knn_mod, logistic = lr_mod)

cell_models <- workflow_set(preproc, models, cross = TRUE)

# ------------------------------------------------------------------------------

\donttest{
cell_models <-
   cell_models \%>\%
   tune_grid(resamples = val_set, grid = 10, metrics = metric_set(roc_auc)) \%>\%
   fit_resamples(resamples = val_set, metrics = metric_set(roc_auc))
cell_models
}
}
